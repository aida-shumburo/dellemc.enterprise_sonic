#
# -*- coding: utf-8 -*-
# Copyright 2025 Dell Inc. or its subsidiaries. All Rights Reserved.
# GNU General Public License v3.0+
# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
"""
The sonic_snmp class
It is in this file where the current configuration (as dict)
is compared to the provided configuration (as dict) and the command set
necessary to bring the current configuration to it's desired end-state is
created
"""
from __future__ import absolute_import, division, print_function
__metaclass__ = type

from copy import deepcopy
from ansible.module_utils.connection import ConnectionError

from ansible_collections.ansible.netcommon.plugins.module_utils.network.common.cfg.base import ConfigBase

from ansible_collections.dellemc.enterprise_sonic.plugins.module_utils.network.sonic.facts.facts import Facts
from ansible_collections.dellemc.enterprise_sonic.plugins.module_utils.network.sonic.sonic import (
    to_request,
    edit_config,
)
from ansible_collections.ansible.netcommon.plugins.module_utils.network.common.utils import (
    to_list,
)
from ansible_collections.dellemc.enterprise_sonic.plugins.module_utils.network.sonic.utils.utils import (
    update_states,
    get_diff,
    remove_none
)

from ansible_collections.dellemc.enterprise_sonic.plugins.module_utils.network.sonic.utils.formatted_diff_utils import (
    get_new_config,
    get_formatted_config_diff
)

from ansible_collections.dellemc.enterprise_sonic.plugins.module_utils.network.sonic.facts.snmp.snmp import SnmpAutoGeneratedValues

PATCH = 'patch'
DELETE = 'delete'


class Snmp(ConfigBase):
    """
    The sonic_snmp class
    """

    gather_subset = [
        '!all',
        '!min',
    ]

    gather_network_resources = [
        'snmp',
    ]

    def __init__(self, module):
        super(Snmp, self).__init__(module)

    def get_snmp_facts(self):
        """ Get the 'facts' (the current configuration)
        :rtype: A dictionary
        :returns: The current configuration as a dictionary
        """
        facts, _warnings = Facts(self._module).get_facts(self.gather_subset, self.gather_network_resources)
        snmp_facts = facts['ansible_network_resources'].get('snmp')

        if not snmp_facts:
            return {}

        return snmp_facts

    def execute_module(self):
        """ Execute the module
        :rtype: A dictionary
        :returns: The result from module execution
        """
        result = dict()
        result['changed'] = False
        warnings = list()
        commands = list()

        existing_snmp_facts = self.get_snmp_facts()
        commands, requests = self.set_config(existing_snmp_facts)

        if commands and requests:
            if not self._module.check_mode:
                try:
                    edit_config(self._module, to_request(self._module, requests))
                except ConnectionError as exc:
                    self._module.fail_json(msg=str(exc), code=exc.code)
            result['changed'] = True
        result['commands'] = commands
        changed_snmp_facts = self.get_snmp_facts()
        result['before'] = existing_snmp_facts
        if result['changed']:
            result['after'] = changed_snmp_facts

        new_config = changed_snmp_facts
        old_config = existing_snmp_facts
        if self._module.check_mode:
            result.pop('after', None)
            new_config = get_new_config(commands, existing_snmp_facts)
            result['after(generated)'] = new_config
        if self._module._diff:
            result['diff'] = get_formatted_config_diff(old_config, new_config, self._module._verbosity)
        result['warnings'] = warnings
        return result

    def set_config(self, existing_snmp_facts):
        """ Collect the configuration from the args passed to the module,
            collect the current configuration (as a dict from facts)
        :rtype: A list
        :returns: the commands necessary to migrate the current configuration
                  to the desired configuration
        """
        want = self._module.params['config']
        have = existing_snmp_facts
        resp = self.set_state(want, have)
        return to_list(resp)

    def set_state(self, want, have):
        """ Select the appropriate function based on the state provided
        :param want: the desired configuration as a dictionary
        :param have: the current configuration as a dictionary
        :rtype: A list
        :returns: the commands necessary to migrate the current configuration
                  to the desired configuration
        """
        commands = []
        requests = []
        state = self._module.params['state']

        if state == 'overridden':
            commands, requests = self._state_overridden(want, have)
        elif state == 'deleted':
            commands, requests = self._state_deleted(want, have)
        elif state == 'merged':
            commands, requests = self._state_merged(want, have)
        elif state == 'replaced':
            commands, requests = self._state_replaced(want, have)

        return commands, requests

    def _state_replaced(self, want, have):
        """ The command generator when state is replaced
        :rtype: A list
        :returns: the commands necessary to migrate the current configuration
                  to the desired configuration
        """
        requests = []
        commands = []
        delete_all = False
        want = remove_none(want)

        if want is None or have is None:
            return commands, requests
        if not want:
            return commands, requests

        diff_want = get_diff(want, have)
        if not diff_want:
            return commands, requests

        commands = deepcopy(want)
        diff = get_diff(have, want)
        if diff is None:
            delete_all = True
            commands = have
        else:
            commands = get_diff(want, diff)

        requests = list(self.get_delete_snmp_request(commands, have, delete_all))

        if len(commands) > 0 and len(requests) > 0:
            commands = update_states(commands, 'deleted')
        else:
            commands = []

        if len(requests) > 0:
            new_have = {}
        else:
            new_have = have

        diff = get_diff(want, new_have)
        merged_commands = diff

        replaced_snmp = self.get_create_snmp_request(merged_commands, have)
        requests.extend(replaced_snmp)
        if merged_commands and len(replaced_snmp) > 0:
            merged_commands = update_states(merged_commands, 'replaced')
            new_commands = list()
            for command in merged_commands:
                new_commands.append(remove_none(command))
            commands = new_commands
        else:
            commands = []

        return commands, requests

    def _state_overridden(self, want, have):
        """ The command generator when state is overridden
        :rtype: A list
        :returns: the commands necessary to migrate the current configuration
                  to the desired configuration
        """
        commands = []
        requests = []
        if want is None or have is None:
            return commands, requests
        want = remove_none(want)
        if not want:
            return commands, requests

        diff_want = get_diff(want, have)
        diff_dont_want = get_diff(have, want)

        if diff_want is None and diff_dont_want is None:
            return commands, requests
        if not diff_dont_want and not diff_want:
            return commands, requests
        if not diff_want:
            return commands, requests

        commands = have
        requests = list(self.get_delete_snmp_request(commands, have, True))

        if commands and len(requests) > 0:
            commands = update_states(commands, "deleted")

        merged_commands = want
        overridden_requests = self.get_create_snmp_request(merged_commands, want)

        requests.extend(overridden_requests)

        if want and len(overridden_requests) > 0:
            merged_commands = update_states(want, "overridden")
            commands = merged_commands
        else:
            commands = []

        return commands, requests

    def _state_merged(self, want, have):
        """ The command generator when state is merged
        :rtype: A list
        :returns: the commands necessary to merge the provided into
                  the current configuration
        """
        commands = get_diff(want, have)
        requests = self.get_create_snmp_request(commands, have)

        if commands and len(requests) > 0:
            commands = update_states(commands, "merged")
        else:
            commands = []

        return commands, requests

    def _state_deleted(self, want, have):
        """ The command generator when state is deleted
        :rtype: A list
        :returns: the commands necessary to remove the current configuration
                  of the provided objects
        """
        requests = []
        commands = []

        if not have or have is None or have is {}:
            return commands, requests

        delete_all = False
        want = remove_none(want)
        have = remove_none(have)

        if have is None:
            return commands, requests
        if not want or want is None:
            commands = deepcopy(have)
            delete_all = True
        else:
            commands = want

        requests = list(self.get_delete_snmp_request(commands, have, delete_all))

        if commands and len(requests) > 0:
            commands = update_states(commands, "deleted")
        else:
            commands = []

        return commands, requests

    def get_create_snmp_request(self, config, have=None):
        """ Create the requests necessary to create the desired configuration
        :rtype: A list
        :returns: the requests necessary to create the desired configuration
        """
        requests = []
        method = PATCH

        if config.get('agentaddress'):
            agentaddress_path = "data/ietf-snmp:snmp/engine"
            payload = self.build_create_agentaddress_payload(config)
            agentaddress_request = {'path': agentaddress_path, 'method': method, 'data': payload}
            requests.append(agentaddress_request)

        if config.get('community'):
            community_requests = self.build_create_community_payload(config, have)
            requests.extend(community_requests)
            group_path = "data/ietf-snmp:snmp/vacm"
            payload = self.build_create_group_community_payload(config)
            group_request = {'path': group_path, 'method': method, 'data': payload}
            requests.append(group_request)

        if config.get('contact'):
            contact_path = "data/ietf-snmp:snmp/ietf-snmp-ext:system/contact"
            payload = self.build_create_contact_payload(config)
            contact_request = {'path': contact_path, 'method': method, 'data': payload}
            requests.append(contact_request)

        if config.get('enable_trap'):
            enable_trap_path = "data/ietf-snmp:snmp/ietf-snmp-ext:system/trap-enable"
            traps_path = "data/ietf-snmp:snmp/ietf-snmp-ext:system/notifications"
            payload_trap_enable, payload = self.build_create_enable_trap_payload(config)
            trap_enable_request = {'path': enable_trap_path, 'method': method, 'data': payload_trap_enable}
            enable_trap_request = {'path': traps_path, 'method': method, 'data': payload}
            requests.append(enable_trap_request)
            requests.append(trap_enable_request)

        if config.get('engine'):
            engine_path = "data/ietf-snmp:snmp/engine"
            payload = self.build_create_engine_payload(config)
            engine_request = {'path': engine_path, 'method': method, 'data': payload}
            requests.append(engine_request)

        if config.get('group'):
            group_path = "data/ietf-snmp:snmp/vacm"
            payload = self.build_create_group_payload(config)
            group_request = {'path': group_path, 'method': method, 'data': payload}
            requests.append(group_request)

        if config.get('host'):
            target_entry = self.get_available_target()
            server_params_path = "data/ietf-snmp:snmp/target-params"
            payload = self.build_create_enable_target_params_payload(config, target_entry)
            target_params_request = {'path': server_params_path, 'method': method, 'data': payload}
            requests.append(target_params_request)
            target_path = "data/ietf-snmp:snmp/target"
            payload = self.build_create_enable_target_payload(config, target_entry)
            target_request = {'path': target_path, 'method': method, 'data': payload}
            requests.append(target_request)

        if config.get('location'):
            location_path = "data/ietf-snmp:snmp/ietf-snmp-ext:system/location"
            payload = self.build_create_location_payload(config)
            location_request = {'path': location_path, 'method': method, 'data': payload}
            requests.append(location_request)

        if config.get('user'):
            user_path = "data/ietf-snmp:snmp/usm/local/user"
            payload = self.build_create_user_payload(config)
            users_request = {'path': user_path, "method": method, 'data': payload}
            requests.append(users_request)

            vacm_path = "data/ietf-snmp:snmp/vacm"
            vacm_payload = self.build_create_vacm_payload(config)
            users_request = {'path': vacm_path, "method": method, 'data': vacm_payload}
            requests.append(users_request)

        if config.get('view'):
            views_path = "data/ietf-snmp:snmp/vacm"
            payload = self.build_create_view_payload(config)
            views_request = {'path': views_path, 'method': method, 'data': payload}
            requests.append(views_request)

        return requests

    def build_create_agentaddress_payload(self, config):
        """ Build the payload for SNMP agentaddress
        :rtype: A dictionary
        :returns: The payload for SNMP agentaddress
        """
        agentaddress = config.get('agentaddress', None)
        agentaddress_list = list()
        agentaddressdict = dict()
        payload_url = dict()
        for conf in agentaddress:
            agentaddress_dict = dict()
            agentaddress_dict['name'] = self.get_agententry()
            agentaddress_dict['udp'] = {'ietf-snmp-ext:interface': conf.get('interface'), 'ip': conf.get('ip'), 'port': conf.get('port')}
            agentaddress_list.append(agentaddress_dict)

        agentaddressdict['listen'] = agentaddress_list
        payload_url['ietf-snmp:engine'] = agentaddressdict
        return payload_url

    def build_create_community_payload(self, config, have):
        """ Build the payload for SNMP community
        :rtype: A dictionary
        :returns: The list of community requests
        """
        community = config.get('community', None)
        community_list = list()
        payload_url = dict()
        community_requests = list()
        community_path = "data/ietf-snmp:snmp/community"

        for conf in community:
            community_dict = dict()
            community_dict['index'] = conf.get('name')
            group_name = conf.get('group')

            if len(have) > 0 and have.get('group'):
                matched_group = next((each_group for each_group in have['group'] if each_group['name'] == group_name), None)
                if matched_group:
                    group_url = "data/ietf-snmp:snmp/vacm/group={0}".format(group_name)
                    group_request = {"path": group_url, "method": DELETE}
                    community_requests.append(group_request)

            community_dict['security-name'] = group_name
            community_list.append(community_dict)
        payload_url['community'] = community_list

        community_requests.append({'path': community_path, 'method': PATCH, 'data': payload_url})
        return community_requests

    def build_create_group_community_payload(self, config):
        """ Build the payload for the group associated with SNMP community
        :rtype: A dictionary
        :returns: The payload for the group associated with SNMP community
        """
        community = config.get('community', None)
        community_list = list()
        payload_url = dict()

        for conf in community:
            group_dict = dict()
            group_dict['name'] = conf.get('group')
            member_dict = dict()
            member_dict['security-model'] = ['v2c']
            member_dict['security-name'] = conf.get('name')
            member_dict_list = list()
            member_dict_list.append(member_dict)
            group_dict['member'] = member_dict_list

            community_list.append(group_dict)

        group_payload = {'group': community_list}
        payload_url['ietf-snmp:vacm'] = group_payload

        return payload_url

    def build_create_engine_payload(self, config):
        """ Build the payload for SNMP engine
        :rtype: A dictionary
        :returns: The payload for SNMP engine
        """
        engine = config.get('engine', None)
        payload_url = dict()

        payload_url['engine'] = {'engine-id': engine}
        return payload_url

    def build_create_user_payload(self, config):
        """ Build the payload for SNMP user
        :rtype: A dictionary
        :returns: The payload for SNMP user
        """
        user = config.get('user', None)
        user_list = list()
        payload_url = dict()

        for conf in user:
            user_dict = dict()
            auth_dict = dict()
            priv_dict = dict()
            user_dict['name'] = conf.get('name')

            user_dict['encrypted'] = conf.get('encrypted')
            auth_type = conf['auth'].get('auth_type')
            priv_type = conf['priv'].get('priv_type')
            auth_key = dict()
            priv_key = dict()
            auth_key['key'] = conf['auth']['key']
            priv_key['key'] = conf['priv']['key']
            auth_dict[auth_type] = auth_key
            priv_dict[priv_type] = priv_key
            user_dict['auth'] = auth_dict
            user_dict['priv'] = priv_dict

            user_list.append(user_dict)

        payload_url['user'] = user_list
        return payload_url

    def build_create_vacm_payload(self, config):
        """ Build the payload for SNMP group members based on the given user information
        :rtpe: A dictionary
        :returns: The payload for SNMP group members
        """
        group_list = list()
        group = config.get('user', None)

        payload_url = dict()

        for conf in group:
            group_dict = dict()
            member = dict()
            if conf.get('group') is None:
                break
            member['security-model'] = ["usm"]
            member['security-name'] = conf.get('name')
            group_dict['member'] = [member]
            group_dict['name'] = conf.get('group')
            group_list.append(group_dict)

        payload_url['ietf-snmp:vacm'] = {'group': group_list}
        return payload_url

    def build_create_view_payload(self, config):
        """ Build the payload for SNMP view
        :rtype: A dictonary
        :returns: The payload for SNMP view
        """
        view_list = list()
        payload_url = dict()
        viewdict = dict()
        view = config.get('view', None)

        for conf in view:
            view_dict = dict()
            view_dict['name'] = conf.get('name')
            view_dict['include'] = conf.get('included')
            view_dict['exclude'] = conf.get('excluded')
            view_list.append(view_dict)
        viewdict['view'] = view_list
        payload_url['ietf-snmp:vacm'] = viewdict
        return payload_url

    def build_create_contact_payload(self, config):
        """ Build the payload for SNMP contact
        :rtype: A dictionary
        :returns: The payload for SNMP contact
        """
        payload_url = dict()
        contact = config.get('contact', None)

        payload_url['ietf-snmp-ext:contact'] = str(contact)
        return payload_url

    def build_create_location_payload(self, config):
        """ Build the payload for SNMP location
        :rtype: A dictionary
        :returns: The payload for SNMP location
        """
        payload_url = dict()
        location = config.get('location', None)

        payload_url['ietf-snmp-ext:location'] = location
        return payload_url

    def build_create_enable_trap_payload(self, config):
        """ Build the payload for SNMP enable_trap
        :rtype: dictionaries regarding the enable traps
        :returns: The payload for SNMP enable_trap
        """
        notification_payload_url = dict()
        all_traps_payload_url = dict()
        enable_trap = config.get('enable_trap', None)
        enable_trap_list = list()

        for conf in enable_trap:
            enable_trap_dict = dict()
            trap_enable = False
            trap_type = conf
            if trap_type:
                if trap_type == 'all':
                    trap_enable = True
                else:
                    notifications = dict()
                    if trap_type == 'auth-fail':
                        enable_trap_dict['authentication-failure-trap'] = True
                    if trap_type == 'bgp':
                        enable_trap_dict['bgp-traps'] = True
                    if trap_type == 'config-change':
                        enable_trap_dict['config-change-trap'] = True
                    if trap_type == 'link-down':
                        enable_trap_dict['link-down-trap'] = True
                    if trap_type == 'link-up':
                        enable_trap_dict['link-up-trap'] = True
                    if trap_type == 'ospf':
                        enable_trap_dict['ospf-traps'] = True
                    notifications['notifications'] = enable_trap_dict

                    enable_trap_list.append(notifications)
        all_traps_payload_url['trap-enable'] = trap_enable
        notification_payload_url['notifications'] = enable_trap_dict
        return all_traps_payload_url, notification_payload_url

    def build_create_group_payload(self, config):
        """ Build the payload for SNMP group
        :rtype: A dictionary
        :returns: The payload for SNMP group
        """
        payload_url = dict()
        group_list = []
        group = config.get('group', None)
        group_payload = dict()
        for conf in list(group):
            group_dict = dict()
            if conf.get('name') is None:
                break
            group_dict['name'] = conf.get('name')
            group_dict['access'] = self.build_create_group_access_payload(conf)
            group_list.append(group_dict)
        group_payload['group'] = group_list
        payload_url['ietf-snmp:vacm'] = group_payload
        return payload_url

    def build_create_group_access_payload(self, config):
        """ Build the payload for the SNMP group access suboption
        :rtype: A list of dictionaries
        :returns: the list of access
        """
        access_list = list()
        access_dicts = config.get('access')
        if access_dicts is None:
            return access_list
        for access in access_dicts:
            access_dict = dict()
            access_dict['context'] = 'Default'
            access_dict['context-match'] = "exact"
            access_dict['notify-view'] = access.get('notify_view')
            access_dict['read-view'] = access.get('read_view')
            access_dict['write-view'] = access.get('write_view')
            security_level = access.get('security_level')
            security_model = access.get('security_model')
            if security_model == 'usm':
                security_model = "v3"
            access_dict['security-level'] = security_level
            access_dict['security-model'] = security_model
            access_list.append(access_dict)
        return access_list

    def build_create_enable_target_payload(self, config, target_entry):
        """ Build the payload for SNMP target information based on the given host configuration
        :rtype: A dictionary
        :returns: The payload for SNMP target
        """
        payload_url = dict()
        target_list = []
        target = config.get('host', None)

        for conf in target:
            target_dict = dict()

            target_dict['name'] = target_entry
            target_dict['retries'] = conf.get('retries')
            tag_list = list()
            if conf.get('tag'):
                tag_list.append(str(conf.get('tag')) + "Notify")
            target_dict["tag"] = tag_list

            target_dict['target-params'] = target_entry
            target_dict['timeout'] = conf.get('timeout')
            target_dict['udp'] = {'ip': conf.get('ip'), 'port': conf.get('port'), 'ietf-snmp-ext:vrf-name': conf.get('vrf')}
            target_dict['source-interface'] = conf.get('source_interface')
            target_list.append(target_dict)

        payload_url['target'] = target_list

        return payload_url

    def build_create_enable_target_params_payload(self, config, target_entry):
        """ Build the payload for SNMP param information based on the given host configuration
        :rtype: A dictionary
        :returns: The payload for SNMP target
        """
        payload_url = dict()
        target_params_list = []

        server = config.get('host', None)

        for conf in server:
            target_params_dict = dict()
            target_entry_name = target_entry
            target_params_dict['name'] = target_entry_name
            type_info = dict()
            if conf.get('user') is None:
                type_info['security-name'] = conf.get('community')
                target_params_dict['v2c'] = type_info
            else:
                server_level = conf.get('user').get('security_level', None)
                if server_level == "auth":
                    type_info['security-level'] = 'auth-no-priv'
                if server_level == "noauth":
                    type_info['security-level'] = 'no-auth-no-priv'
                if server_level == "priv":
                    type_info['security-level'] = 'auth-priv'
                type_info['user-name'] = conf.get('user').get('name')
                target_params_dict['usm'] = type_info

            target_params_list.append(target_params_dict)

        payload_url['target-params'] = target_params_list

        return payload_url

    def get_delete_snmp_request(self, configs, have, delete_all):
        """ Create the requests necessary to delete the given configuration
        :rtype: A list
        :returns: The list of requests to delete the given configuration
        """
        requests = list()

        if not configs:
            return requests

        agentaddress_requests_list = []
        community_requests_list = []
        contact_requests_list = []
        enable_trap_requests_list = []
        engine_requests_list = []
        group_requests_list = []
        host_requests_list = []
        location_requests_list = []
        user_requests_list = []
        view_requests_list = []

        agentaddress = 'agentaddress' in configs
        community = 'community' in configs
        contact = 'contact' in configs
        enable_trap = 'enable_traps' in configs
        engine = 'engine' in configs
        group = 'group' in configs
        host = 'host' in configs
        location = 'location' in configs
        user = 'user' in configs
        view = 'view' in configs

        have_agentaddress = have.get('agentaddress', None)
        have_community = have.get('community', None)
        have_contact = have.get('contact', None)
        have_enable_trap = have.get('enable_trap', None)
        have_engine = have.get('engine', None)
        have_group = have.get('group', None)
        have_host = have.get('host', None)
        have_location = have.get('location', None)
        have_user = have.get('user', None)
        have_view = have.get('view', None)

        if delete_all or agentaddress:
            if have_agentaddress is not None:
                agentaddress_requests = list()
                if configs['agentaddress'] is None:
                    agentaddress_url = "data/ietf-snmp:snmp/engine/listen"
                    agentaddress_request = {"path": agentaddress_url, "method": DELETE}
                    agentaddress_requests.append(agentaddress_request)
                else:
                    for want in configs['agentaddress']:
                        matched_agentaddress = next((each_snmp for each_snmp in have['agentaddress'] if each_snmp['ip'] == want['ip']), None)
                        if matched_agentaddress:
                            name = self.get_delete_agententry(matched_agentaddress)
                            agentaddress_url = "data/ietf-snmp:snmp/engine/listen={0}".format(name)
                            agentaddress_request = {"path": agentaddress_url, "method": DELETE}
                            agentaddress_requests.append(agentaddress_request)
                if agentaddress_requests:
                    agentaddress_requests_list.extend(agentaddress_requests)

        if delete_all or community:
            if have_community is not None:
                community_requests = list()
                if configs['community'] is None:
                    community_url = "data/ietf-snmp:snmp/community"
                    community_request = {"path": community_url, "method": DELETE}
                    community_requests.append(community_request)
                else:
                    for want in configs['community']:
                        matched_community = next((each_snmp for each_snmp in have['community'] if each_snmp['name'] == want['name']), None)
                        if matched_community:
                            community_name = matched_community['name']
                            group_name = matched_community['group']
                            community_url = "data/ietf-snmp:snmp/community={0}".format(community_name)
                            community_request = {"path": community_url, "method": DELETE}
                            community_requests.append(community_request)
                            if have_group is not None:
                                if group_name in have['group']:
                                    group_community_url = "data/ietf-snmp:snmp/vacm/group={0}".format(group_name)
                                    group_request = {"path": group_community_url, "method": DELETE}
                                    community_requests.append(group_request)
                if community_requests:
                    community_requests_list.extend(community_requests)

        if delete_all or contact:
            if have_contact is not None:
                contact_url = "data/ietf-snmp:snmp/ietf-snmp-ext:system/contact"
                contact_request = {"path": contact_url, "method": DELETE}
                contact_requests_list.append(contact_request)

        if delete_all or enable_trap:
            if have_enable_trap is not None:
                enable_trap_requests = list()
                if configs['enable_trap'] is None:
                    enable_trap_url = ""
                    trap = have['enable_trap']
                    if trap == 'all':
                        enable_trap_url = "data/ietf-snmp:snmp/ietf-snmp-ext:system/trap-enable"
                    if trap == 'link-down':
                        enable_trap_url = "data/ietf-snmp:snmp/ietf-snmp-ext:system/notifications/link-down-trap"
                    if trap == 'link-up':
                        enable_trap_url = "data/ietf-snmp:snmp/ietf-snmp-ext:system/notifications/link-up-trap"
                    if trap == 'config-change':
                        enable_trap_url = "data/ietf-snmp:snmp/ietf-snmp-ext:system/notifications/config-change-trap"
                    if trap == 'ospf':
                        enable_trap_url = "data/ietf-snmp:snmp/ietf-snmp-ext:system/notifications/ospf-traps"
                    if trap == 'bgp':
                        enable_trap_url = "data/ietf-snmp:snmp/ietf-snmp-ext:system/notifications/bgp-traps"
                    if trap == 'auth-fail':
                        enable_trap_url = "data/ietf-snmp:snmp/ietf-snmp-ext:system/notifications/authentication-failure-trap"
                    enable_trap_request = {"path": enable_trap_url, "method": DELETE}
                    enable_trap_requests.append(enable_trap_request)
                else:
                    for want in configs['enable_trap']:
                        matched_enable_trap = next((each_snmp for each_snmp in have['enable_trap'] if each_snmp[0] == want[0]), None)
                        enable_trap_url = ""
                        if matched_enable_trap:
                            if matched_enable_trap == 'all':
                                enable_trap_url = "data/ietf-snmp:snmp/ietf-snmp-ext:system/trap-enable"
                            if matched_enable_trap == 'link-down':
                                enable_trap_url = "data/ietf-snmp:snmp/ietf-snmp-ext:system/notifications/link-down-trap"
                            if matched_enable_trap == 'link-up':
                                enable_trap_url = "data/ietf-snmp:snmp/ietf-snmp-ext:system/notifications/link-up-trap"
                            if matched_enable_trap == 'config-change':
                                enable_trap_url = "data/ietf-snmp:snmp/ietf-snmp-ext:system/notifications/config-change-trap"
                            if matched_enable_trap == 'ospf':
                                enable_trap_url = "data/ietf-snmp:snmp/ietf-snmp-ext:system/notifications/ospf-traps"
                            if matched_enable_trap == 'bgp':
                                enable_trap_url = "data/ietf-snmp:snmp/ietf-snmp-ext:system/notifications/bgp-traps"
                            if matched_enable_trap == 'auth-fail':
                                enable_trap_url = "data/ietf-snmp:snmp/ietf-snmp-ext:system/notifications/authentication-failure-trap"

                            enable_trap_request = {"path": enable_trap_url, "method": DELETE}
                            enable_trap_requests.append(enable_trap_request)
                if enable_trap_requests:
                    enable_trap_requests_list.extend(enable_trap_requests)

        if delete_all or engine:
            if have_engine is not None:
                engine_url = "data/ietf-snmp:snmp/engine"
                engine_request = {"path": engine_url, "method": DELETE}
                engine_requests_list.append(engine_request)
            else:
                if engine:
                    configs.pop('engine')

        if delete_all or group:
            if have_group is not None:
                group_requests = list()

                if configs['group'] is None or configs['group'] == []:
                    group_url = "data/ietf-snmp:snmp/vacm/group"
                    group_request = {"path": group_url, "method": DELETE}
                    group_requests.append(group_request)
                else:
                    for want in configs['group']:
                        if want.get('name') is None:
                            break
                        matched_group = next((each_snmp for each_snmp in have['group'] if each_snmp['name'] == want['name']), None)
                        if matched_group:
                            group_name = matched_group['name']
                            group_url = "data/ietf-snmp:snmp/vacm/group={0}".format(group_name)
                            group_request = {"path": group_url, "method": DELETE}
                            group_requests.append(group_request)
                if group_requests:
                    group_requests_list.extend(group_requests)

        if delete_all or host:
            if have_host is not None:
                host_requests = list()
                if configs['host'] is None or configs['host'] == []:
                    host_target_url = "data/ietf-snmp:snmp/target"
                    host_request = {"path": host_target_url, "method": DELETE}
                    host_requests.append(host_request)
                    host_target_params_url = "data/ietf-snmp:snmp/target-params"
                    host_request = {"path": host_target_params_url, "method": DELETE}
                    host_requests.append(host_request)
                else:
                    for want in configs['host']:
                        matched_host, name = self.get_host(want=want, have=have)
                        if matched_host is not None:
                            host_target_url = "data/ietf-snmp:snmp/target={0}".format(name)
                            host_request = {"path": host_target_url, "method": DELETE}
                            host_requests.append(host_request)
                            host_target_params_url = "data/ietf-snmp:snmp/target-params={0}".format(name)
                            host_request = {"path": host_target_params_url, "method": DELETE}
                            host_requests.append(host_request)
                if host_requests:
                    host_requests_list.extend(host_requests)

        if delete_all or location:
            if have_location is not None:
                location_url = "data/ietf-snmp:snmp/ietf-snmp-ext:system/location"
                location_request = {"path": location_url, "method": DELETE}
                location_requests_list.append(location_request)

        if delete_all or user:
            if have_user is not None:
                user_requests = list()
                if len(configs['user']) > 0:
                    user_url = "data/ietf-snmp:snmp/usm/local/user"
                    user_request = {"path": user_url, "method": DELETE}
                    user_requests.append(user_request)
                else:
                    for want in configs['user']:
                        matched_user = next((each_snmp for each_snmp in have['user'] if each_snmp['name'] == want['name']), None)
                        if matched_user:
                            user_name = matched_user['name']
                            user_url = "data/ietf-snmp:snmp/usm/local/user={0}".format(user_name)
                            user_request = {"path": user_url, "method": DELETE}
                            user_requests.append(user_request)
                            group_name = matched_user['group']
                            group_url = "data/ietf-snmp:snmp/vacm/group={0}".format(group_name)
                            group_request = {"path": group_url, "method": DELETE}
                            user_requests.append(group_request)
                if user_requests:
                    user_requests_list.extend(user_requests)

        if delete_all or view:
            if have_view is not None:
                view_requests = list()
                if configs['view'] is None or len(configs['view']) == 0:
                    view_url = "data/ietf-snmp:snmp/vacm/view"
                    view_request = {"path": view_url, "method": DELETE}
                    view_requests.append(view_request)
                else:
                    for want in configs['view']:
                        matched_view = next((each_snmp for each_snmp in have['view'] if each_snmp['name'] == want['name']), None)
                        if matched_view:
                            view_name = matched_view['name']
                            view_url = "data/ietf-snmp:snmp/vacm/view={0}".format(view_name)
                            view_request = {"path": view_url, "method": DELETE}
                            view_requests.append(view_request)
                if view_requests:
                    view_requests_list.extend(view_requests)

        if agentaddress_requests_list:
            requests.extend(agentaddress_requests_list)
        if community_requests_list:
            requests.extend(community_requests_list)
        if contact_requests_list:
            requests.extend(contact_requests_list)
        if enable_trap_requests_list:
            requests.extend(enable_trap_requests_list)
        if engine_requests_list:
            requests.extend(engine_requests_list)
        if group_requests_list:
            requests.extend(group_requests_list)
        if host_requests_list:
            requests.extend(host_requests_list)
        if location_requests_list:
            requests.extend(location_requests_list)
        if user_requests_list:
            requests.extend(user_requests_list)
        if view_requests_list:
            requests.extend(view_requests_list)

        return requests

    def get_matched_access(self, access_list, want_access):
        """ Finds and returns the access list that matches the wanted access list
        :rtype: A list
        :returns: the access list that matches the wanted access list
        """
        matched_access = list()
        for want in want_access:
            matched_want = next((each_access for each_access in access_list
                                 if each_access['security_model'] == want['security_model']
                                 and each_access['security_level'] == want['security_level']
                                 and each_access['read_view'] == want['read_view']
                                 and each_access['write_view'] == want['write_view']
                                 and each_access['notify_view'] == want['notify_view']), None)
            matched_access.append(matched_want)
        return matched_access

    def get_host(self, want, have):
        """ Finds and returns the host that matches the wanted host
        :rtype: A list
        :returns: the host that matches the wanted host
        """
        for each_host in have.get('host'):
            if each_host['ip'] == want['ip']:
                return each_host, self.get_delete_target(each_host)
        return {}, ""

    def get_available_target(self):
        """ Get and return the first available targetEntry that is not already taken
        :rtype: str
        :returns: the first available targetEntry that is not already taken
        """
        all_hosts = SnmpAutoGeneratedValues.get_available_target(SnmpAutoGeneratedValues)
        target = 1
        for host in all_hosts:
            current_target = "targetEntry" + str(target)
            if current_target != host['target-entry']:
                return current_target
            target = target + 1
        return "targetEntry" + str(target)

    def get_delete_target(self, current_host):
        """ Get the targetEntry of the given host config
        :rtype: str
        :returns: Get the targetEntry of the given host config
        """
        all_hosts = SnmpAutoGeneratedValues.get_available_target(SnmpAutoGeneratedValues)

        for host in all_hosts:
            matched_host = next((each_host for each_host in host.get('host-info') if each_host['ip'] == current_host['ip']), None)
            if matched_host:
                return host['target-entry']
        return None

    def get_agententry(self):
        """ Get and return the first available agentEntry that is already taken
        :rtype: str
        :returns: the first available agentEntry that is not already taken
        """
        all_agentaddresses = SnmpAutoGeneratedValues.get_agent_entry(SnmpAutoGeneratedValues)

        agent = 1
        for agentaddress in all_agentaddresses:
            current_agententry = "AgentEntry" + str(agent)
            if current_agententry != agentaddress['agent-entry-name']:
                return current_agententry
            agent = agent + 1
        return "AgentEntry" + str(agent)

    def get_delete_agententry(self, current_agentaddress):
        """ Get the agentEntry of the given agentaddress config
        :rtype: str
        :returns: Get the agentEntry of the given agentaddress config
        """
        all_agentaddresses = SnmpAutoGeneratedValues.get_agent_entry(SnmpAutoGeneratedValues)

        for agentaddress in all_agentaddresses:
            if agentaddress.get('address').get('ip') == current_agentaddress['ip']:
                return agentaddress['agent-entry-name']
        return None
